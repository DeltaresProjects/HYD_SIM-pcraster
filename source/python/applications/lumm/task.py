"""
Module for the Task class implementation.
"""

import exceptions, os, sys, types, utils



class Task:
  """
  Base class for all types of tasks.

  This class defines the interface common to all tasks. Important member
  functions are L{initialise}, L{run} and L{clean}. Most tasks need to
  implement these.

  This class has support for options. Call L{parseOptions} to parse the
  options option value from the configuration section and call
  L{optionIsSet} to see whether an option is set.

  There are two types of options:
    1. Configuration section options, with the name: value syntax, present in
       the configurationItems constructor argument.
    2. A configuration section option with the name 'options'. This option
       named options is a way to tweak the working of a task.

  Strategy for deciding where to put temporary or generated files: in principle
  all files not needed by the end user should be put in one of the
  *TempDirectoryName() locations. It might be needed to deviate from this rule
  but make sure that the task deletes the generated stuff afterwards.
  """

  # Keep track of the number of tasks created.
  __nrTasksCreated = 0

  def __init__(self,
         description,
         scriptDirectoryName,
         tempDirectoryName,
         outputDirectoryName,
         configurationItems):
    """
    Constructor.

    Calls: L{setTempDirectoryName}

    @type description: string
    @param description: Short message describing the goal of the task.
    @type scriptDirectoryName: string
    @param scriptDirectoryName: Name of directory where the scripts used by
         the tasks can be found.
    @type tempDirectoryName: string
    @param tempDirectoryName: Name of directory for temp stuff generated by the
         task. Each task is obliged to remove temp stuff after completion
         (see L{clean}).
    @type outputDirectoryName: string
    @param outputDirectoryName: Name of directory for stuff generated by the
         task which needs to remain present after completion.
    @type configurationItems: dictionary
    @param configurationItems: Collection with possibly more than one section
         and per section name - value pairs of options. See
         L{Task.configurationItems}.
  """
    Task.__nrTasksCreated += 1

    description = description.strip()
    assert description
    self.__description = description
    self.__scriptDirectoryName = None
    self.__tempDirectoryName = None
    self.__outputDirectoryName = None

    self.__setScriptDirectoryName(scriptDirectoryName)

    if tempDirectoryName != None:
      self.setTempDirectoryName(tempDirectoryName)

    if outputDirectoryName != None:
      self.setOutputDirectoryName(outputDirectoryName)

    self.__configurationItems = configurationItems
    self.__sectionTitle = u""
    self.__logFilename = None
    self.__options = []

  def __del__(self):
    """
    Destructor.

    The tree of subdirectories created in L{__createTempDirectoryTree} is
    removed again. Tasks are required to remove their temp stuff from these
    directories, otherwise removing them will fail.
    """
    Task.__nrTasksCreated -= 1

    if not Task.__nrTasksCreated:
      if self.__tempDirectoryName:
        for type in ["validation", "model"]:
          directoryName = os.path.join(self.tempDirectoryName(), type)
          assert os.path.exists(directoryName)
          # FIXME remove lingering files ourselves?
          os.rmdir(directoryName)

  def description(self):
    """
    @return: The description of the task.
    """
    return self.__description

  def decorateOptionException(self,
         function):
    """
    Calls function and, if it throws an exception, prepends it with an error message mentioning the section title.

    @type function: function
    @param function: Object which can be called.
    @exception Exception: When the function called throws an exception.
    """
    try:
      function()
    except AssertionError, exception:
      raise
    except Exception, exception:
      utils.raiseException(u"error while testing value in section: %s" %
         (self.sectionTitle()), exception)

  def initialise(self):
    """
    Initialises the task. This default does nothing.

    Typically code is put in here to test whether the task is set up
    correctly (all required configuration items given and values within valid
    ranges?, all input files readable?, all output files writable?).

    This setup is to prevent that tasks start running while one or more of them
    is not set up correctly, which would then be detected after possibly a long
    time.
    """
    pass

  def run(self):
    """
    Performs the task. The default does nothing.

    Here the meat of the task is put.
    """
    pass

  def clean(self):
    """
    Cleans all temporary stuff generated by the task. The default does nothing.

    Be sure not to keep stuff lingering around in the filesystem!

    This step is separated from the run step because subsequent tasks might
    want to use temporary stuff of previous tasks as input.
    """
    pass

  def __show(self,
         file,
         messages,
         appendNewLineIfNeeded=True):
    """
    Prints the messages in file.

    Each message printed is appended with a newline.

    @type file: file
    @param file: File to print the message in.
    @type messages: String or list of strings.
    @param messages: Strings to print to file.
    """
    if isinstance(messages, types.ListType):
      for message in messages:
        self.__show(stream, message)
    else:
      file.write(messages)

      if appendNewLineIfNeeded:
        file.write("\n")

      file.flush()

      self.writeLog("%s\n" % (messages))

  def showInfo(self,
         messages,
         appendNewLineIfNeeded=True):
    """
    Prints the messages to standard output.

    Calls: L{__show}.
    """
    self.__show(sys.stdout, messages, appendNewLineIfNeeded)

  def showDeprecationWarning(self,
         messages,
         appendNewLineIfNeeded=True):
    """
    Shows a message stating that a feature is depricated.

    @param messages: One or more messages to be shown.
    @type messages: string or list of strings
    """
    if isinstance(messages, types.ListType):
      for i in range(len(messages)):
        messages[i] = "depricated feature warning: %s" % (messages[i])
    else:
      messages = "depricated feature warning: %s" % (messages)

    self.__show(sys.stdout, messages, appendNewLineIfNeeded)

  def setSectionTitle(self,
         title):
    """
    Sets the section title for this task to title.

    @type title: string
    @param title: Title of configuration file section for this task.
    """
    self.testRequiredSection(title)
    self.__sectionTitle = title

  def sectionTitle(self):
    """
    Returns the configuration file section title for this task.

    This set-up assumes each task has one section in the configuration file
    which might not be the case in the future.
    """
    return self.__sectionTitle

  def configurationItems(self):
    """
    Returns the configuration items.

    This is a dictionary with section name as key and a list of string pairs
    as value. The first element of the pair is the name of the option and the
    second the value.
    """
    return self.__configurationItems

  def testRequiredSection(self,
         name):
    """
    Tests whether the configuration items set in the constructor contains a certain section.

    @param name: Name of section to look for.
    @type name: string
    @exception exceptions.LookupError: If section not present.
    """
    if not self.hasSection(name):
      raise exceptions.LookupError(u"required section %s is missing" % name)

  def testRequiredOption(self,
         name):
    """
    Tests whether section contains an option with name.

    @type name: string
    @param name: Name of option in section in configuration file.
    @exception exceptions.LookupError: If option not present.
    """
    if not self.hasOption(name):
      raise exceptions.LookupError(u"required option %s is missing" % name)

  def hasSection(self,
         section):
    return self.configurationItems().has_key(section)

  def hasOption(self,
         name):
    """
    Test whether section contains an option with name.

    This function does not guarantee that the option has a value.

    @type name: string
    @param name: Name of option in section in configuration file.
    """
    for item in self.configurationItems()[self.sectionTitle()]:
      if item[0] == name:
        return True

    return False

  def option(self,
         name):
    """
    Returns the value of option name in section in configuration file.

    @type name: string
    @param name: Name of option in section in configuration file.

    This function assumes that an option with the name exists in the section
    and that it has a value set.
    """
    assert(self.hasOption(name))

    for item in self.configurationItems()[self.sectionTitle()]:
      if item[0] == name:
        assert len(item) == 2
        return item[1]

  def __testScriptDirectoryName(self):
    """
    FIXME
    """
    utils.testDirectoryIsReadable(self.scriptDirectoryName())

  def __testTempDirectoryName(self):
    """
    FIXME
    """
    utils.testDirectoryIsWritable(self.tempDirectoryName())

  def __createTempDirectoryTree(self):
    """
    FIXME
    """
    # Standard set of sub directories some tasks might want to use to organise
    # their data.
    for type in ["validation", "model"]:
      directoryName = os.path.join(self.tempDirectoryName(), type)

      if not os.path.exists(directoryName):
        os.mkdir(directoryName)

  def __setScriptDirectoryName(self,
         directoryName):
    """
    FIXME
    """
    assert not self.__scriptDirectoryName
    self.__scriptDirectoryName = os.path.abspath(directoryName)
    self.__testScriptDirectoryName()

  def scriptDirectoryName(self):
    """
    FIXME
    """
    assert self.__scriptDirectoryName
    return self.__scriptDirectoryName

  def setTempDirectoryName(self,
         directoryName):
    """
    Calls: L{__testTempDirectoryName}, L{__createTempDirectoryTree}
    """
    assert not self.__tempDirectoryName
    self.__tempDirectoryName = os.path.abspath(directoryName)
    assert self.__tempDirectoryName
    self.__testTempDirectoryName()
    self.__createTempDirectoryTree()

  def tempDirectoryName(self):
    """
    FIXME
    """
    assert self.__tempDirectoryName
    return self.__tempDirectoryName

  def validationTempDirectoryName(self):
    """
    FIXME
    """
    return os.path.join(self.tempDirectoryName(), "validation")

  def modelTempDirectoryName(self):
    """
    FIXME
    """
    return os.path.join(self.tempDirectoryName(), "model")

  def __testOutputDirectoryName(self):
    """
    FIXME
    """
    utils.testDirectoryIsWritable(self.outputDirectoryName())

  def __createOutputDirectoryTree(self):
    """
    FIXME
    """
    # Standard set of sub directories some tasks might want to use to organise
    # their data.
    for type in ["validation", "model"]:
      directoryName = os.path.join(self.outputDirectoryName(), type)

      if not os.path.exists(directoryName):
        os.mkdir(directoryName)

  def setOutputDirectoryName(self,
         directoryName):
    """
    Calls: L{__testOutputDirectoryName}, L{__createOutputDirectoryTree}
    """
    assert not self.__outputDirectoryName
    self.__outputDirectoryName = os.path.abspath(directoryName)
    assert self.__outputDirectoryName
    self.__testOutputDirectoryName()
    self.__createOutputDirectoryTree()

  def outputDirectoryName(self):
    """
    FIXME
    """
    assert self.__outputDirectoryName
    return self.__outputDirectoryName

  def validationOutputDirectoryName(self):
    """
    FIXME
    """
    return os.path.join(self.outputDirectoryName(), "validation")

  def modelOutputDirectoryName(self):
    """
    FIXME
    """
    return os.path.join(self.outputDirectoryName(), "model")

  def setLogFilename(self,
         filename):
    assert utils.fileIsWriteable(filename)
    self.__logFilename = os.path.abspath(filename)

  def logShouldBeCreated(self):
    return bool(self.__logFilename)

  def logFilename(self):
    return self.__logFilename

  def writeLog(self,
         message):
    if self.logShouldBeCreated():
      file(self.logFilename(), "a").write(message)

  def parseOptions(self):
    """
    Parses the value given after the options option.

    This function assumes the options option is present in the task's section.
    """
    assert self.hasOption(name)

    for option in utils.parseOptions(self.option(name)):
      self.addOption(option)

  def optionIsSet(self,
         name):
    """
    Returns whether an option named name is set.

    @type name: string
    @param name: Name of the option to test.
    """
    return name in self.__options

  def addOption(self,
         name):
    """
    Adds the option named name to the collection.

    The option is only added if it not already exists.

    @type name: string
    @param name: Name of the option to set.
    """
    if not self.optionIsSet(name):
      self.__options.append(name)


