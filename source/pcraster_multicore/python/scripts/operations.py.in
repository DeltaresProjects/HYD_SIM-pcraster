# This file was generated during the PCRaster build.
# Do not edit!
import types as _types
import pcraster as _pcraster
import _pcraster_multicore as _pmc


def set_nr_worker_threads(arg1):
    _pmc.set_nr_worker_threads(arg1)


def nr_worker_threads():
    return _pmc.nr_worker_threads()





# just get a spatial or nonspatial
# assign a valuescale if necessary
# correct SV of an operation should be checked in the C++ code
def _get_field(arg):
    if isinstance(arg, _pcraster.Field):
        return(arg)
    elif isinstance(arg, _types.StringTypes):
        return(_pcraster.readmap(arg))
    elif isinstance(arg, _types.BooleanType):
        return(_pmc._newNonSpatialBoolean(arg))
    elif isinstance(arg, _types.IntType) or isinstance(arg, _types.LongType):
        return(_pmc._newNonSpatialNominal(arg))
    elif isinstance(arg, _types.FloatType):
        return(_pmc._newNonSpatialScalar(arg))
    else:
        msg = "conversion of argument with type '{}' to PCRaster not possible".format(type(arg).__name__)
        raise RuntimeError(msg)


def cover(*args):
    try:
        fields = list(args)
        for i, field in enumerate(fields):
            fields[i] = _get_field(field)
        return _pmc.cover(fields)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore cover: {}".format(str(exception)))


def max(*args):
    try:
        fields = list(args)
        for i, field in enumerate(fields):
            fields[i] = _get_field(field)
        return _pmc.maximum(fields)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore maximum: {}".format(str(exception)))


def min(*args):
    try:
        fields = list(args)
        for i, field in enumerate(fields):
            fields[i] = _get_field(field)
        return _pmc.minimum(fields)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore minimum: {}".format(str(exception)))




def ifthen(arg1, arg2):

    # to mimic the PCRaster model engine behaviour
    if not isinstance(arg2, _pcraster.Field):
        raise RuntimeError("Use a conversion function to pick a data type")

    try:
        arg1 = _get_field(arg1)
        arg2 = _get_field(arg2)
        return _pmc.ifthen(arg1, arg2)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore ifthen: {}".format(str(exception)))


def ifthenelse(arg1, arg2, arg3):

    # to mimic the PCRaster model engine behaviour
    if not ( isinstance(arg2, _pcraster.Field) or isinstance(arg3, _pcraster.Field) ):
        raise RuntimeError("Use a conversion function to pick a data type")
    try:
        arg1 = _get_field(arg1)
        arg2 = _get_field(arg2)
        arg3 = _get_field(arg3)
        return _pmc.ifthenelse(arg1, arg2, arg3)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore ifthenelse: {}".format(str(exception)))




def boolean(arg1):

    # Fallback to model_engine
    if isinstance(arg1, _pcraster.Field):
        if arg1.dataType() ==  _pcraster.VALUESCALE.Directional:
            return _pcraster.scalar(arg1)

    try:
        arg1 = _get_field(arg1)
        return _pmc.boolean(arg1)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore boolean: {}".format(str(exception)))


def nominal(arg1):

    # Fallback to model_engine
    if isinstance(arg1, _pcraster.Field):
        if arg1.dataType() ==  _pcraster.VALUESCALE.Directional:
            return _pcraster.scalar(arg1)

    try:
        arg1 = _get_field(arg1)
        return _pmc.nominal(arg1)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore nominal: {}".format(str(exception)))


def ordinal(arg1):

    # Fallback to model_engine
    if isinstance(arg1, _pcraster.Field):
        if arg1.dataType() ==  _pcraster.VALUESCALE.Directional:
            return _pcraster.scalar(arg1)

    try:
        arg1 = _get_field(arg1)
        return _pmc.ordinal(arg1)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore ordinal: {}".format(str(exception)))


def scalar(arg1):

    # Fallback to model_engine
    if isinstance(arg1, _pcraster.Field):
        if arg1.dataType() ==  _pcraster.VALUESCALE.Directional:
            return _pcraster.scalar(arg1)
    try:
        arg1 = _get_field(arg1)
        return _pmc.scalar(arg1)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore scalar: {}".format(str(exception)))






# these ones below here can be generated?!

def slope(arg1):
    try:
        arg1 = _get_field(arg1)
        return _pmc.slope(arg1)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore slope: {}".format(str(exception)))


def equal(arg1, arg2):
    try:
        arg1 = _get_field(arg1)
        arg2 = _get_field(arg2)
        return _pmc.equal(arg1, arg2)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore equal: {}".format(str(exception)))


def unequal(arg1, arg2):
    try:
        arg1 = _get_field(arg1)
        arg2 = _get_field(arg2)
        return _pmc.unequal(arg1, arg2)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore unequal: {}".format(str(exception)))


def greater(arg1, arg2):
    try:
        arg1 = _get_field(arg1)
        arg2 = _get_field(arg2)
        return _pmc.greater(arg1, arg2)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore greater: {}".format(str(exception)))


def greater_equal(arg1, arg2):
    try:
        arg1 = _get_field(arg1)
        arg2 = _get_field(arg2)
        return _pmc.greater_equal(arg1, arg2)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore greater_equal: {}".format(str(exception)))


def less(arg1, arg2):
    try:
        arg1 = _get_field(arg1)
        arg2 = _get_field(arg2)
        return _pmc.less(arg1, arg2)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore less: {}".format(str(exception)))


def less_equal(arg1, arg2):
    try:
        arg1 = _get_field(arg1)
        arg2 = _get_field(arg2)
        return _pmc.less_equal(arg1, arg2)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore less_equal: {}".format(str(exception)))


def _and(arg1, arg2):
    try:
        arg1 = _get_field(arg1)
        arg2 = _get_field(arg2)
        return _pmc._and(arg1, arg2)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore and: {}".format(str(exception)))


def _or(arg1, arg2):
    try:
        arg1 = _get_field(arg1)
        arg2 = _get_field(arg2)
        return _pmc._or(arg1, arg2)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore or: {}".format(str(exception)))


def _xor(arg1, arg2):
    try:
        arg1 = _get_field(arg1)
        arg2 = _get_field(arg2)
        return _pmc._xor(arg1, arg2)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore xor: {}".format(str(exception)))


def _not(arg1):
    try:
        arg1 = _get_field(arg1)
        return _pmc._not(arg1)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore not: {}".format(str(exception)))


def defined(arg1):
    try:
        arg1 = _get_field(arg1)
        return _pmc.defined(arg1)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore defined: {}".format(str(exception)))


def add(arg1, arg2):
    try:
        arg1 = _get_field(arg1)
        arg2 = _get_field(arg2)
        return _pmc.add(arg1, arg2)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore add: {}".format(str(exception)))


def sub(arg1, arg2):
    try:
        arg1 = _get_field(arg1)
        arg2 = _get_field(arg2)
        return _pmc.sub(arg1, arg2)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore sub: {}".format(str(exception)))


def mul(arg1, arg2):
    try:
        arg1 = _get_field(arg1)
        arg2 = _get_field(arg2)
        return _pmc.mul(arg1, arg2)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore mul: {}".format(str(exception)))


def div(arg1, arg2):
    try:
        arg1 = _get_field(arg1)
        arg2 = _get_field(arg2)
        return _pmc.div(arg1, arg2)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore div: {}".format(str(exception)))


def sqrt(arg1):
    try:
        arg1 = _get_field(arg1)
        return _pmc.sqrt(arg1)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore sqrt: {}".format(str(exception)))


def power(arg1, arg2):
    try:
        arg1 = _get_field(arg1)
        arg2 = _get_field(arg2)
        return _pmc.power(arg1, arg2)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore power: {}".format(str(exception)))


def abs(arg1):
    try:
        arg1 = _get_field(arg1)
        return _pmc.abs(arg1)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore abs: {}".format(str(exception)))


def cos(arg1):
    try:
        arg1 = _get_field(arg1)
        return _pmc.cos(arg1)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore cos: {}".format(str(exception)))


def sin(arg1):
    try:
        arg1 = _get_field(arg1)
        return _pmc.sin(arg1)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore sin: {}".format(str(exception)))


def tan(arg1):
    try:
        arg1 = _get_field(arg1)
        return _pmc.tan(arg1)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore tan: {}".format(str(exception)))


def sqr(arg1):
    try:
        arg1 = _get_field(arg1)
        return _pmc.sqr(arg1)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore sqr: {}".format(str(exception)))



def mapmaximum(arg1):
    try:
        arg1 = _get_field(arg1)
        return _pmc.mapmaximum(arg1)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore mapmaximum: {}".format(str(exception)))


def mapminimum(arg1):
    try:
        arg1 = _get_field(arg1)
        return _pmc.mapminimum(arg1)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore mapminimum: {}".format(str(exception)))




def acos(arg1):
    try:
        arg1 = _get_field(arg1)
        return _pmc.acos(arg1)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore acos: {}".format(str(exception)))


def asin(arg1):
    try:
        arg1 = _get_field(arg1)
        return _pmc.asin(arg1)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore asin: {}".format(str(exception)))


def atan(arg1):
    try:
        arg1 = _get_field(arg1)
        return _pmc.atan(arg1)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore atan: {}".format(str(exception)))


def fac(arg1):
    try:
        arg1 = _get_field(arg1)
        return _pmc.fac(arg1)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore fac: {}".format(str(exception)))


def window4total(arg1):
    try:
        arg1 = _get_field(arg1)
        return _pmc.window4total(arg1)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore window4total: {}".format(str(exception)))


def ln(arg1):
    try:
        arg1 = _get_field(arg1)
        return _pmc.ln(arg1)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore ln: {}".format(str(exception)))


def log10(arg1):
    try:
        arg1 = _get_field(arg1)
        return _pmc.log10(arg1)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore log10: {}".format(str(exception)))


def rounddown(arg1):
    try:
        arg1 = _get_field(arg1)
        return _pmc.rounddown(arg1)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore rounddown: {}".format(str(exception)))


def roundup(arg1):
    try:
        arg1 = _get_field(arg1)
        return _pmc.roundup(arg1)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore roundup: {}".format(str(exception)))


def roundoff(arg1):
    try:
        arg1 = _get_field(arg1)
        return _pmc.roundoff(arg1)
    except RuntimeError as exception:
        raise RuntimeError("pcraster.multicore roundoff: {}".format(str(exception)))



# to be generated...

abs.__doc__ = _pmc.abs.__doc__
acos.__doc__ = _pmc.acos.__doc__
add.__doc__ = _pmc.add.__doc__
asin.__doc__ = _pmc.asin.__doc__
atan.__doc__ = _pmc.atan.__doc__
boolean.__doc__ = _pmc.boolean.__doc__
cos.__doc__ = _pmc.cos.__doc__
cover.__doc__ = _pmc.cover.__doc__
defined.__doc__ = _pmc.defined.__doc__
div.__doc__ = _pmc.div.__doc__
equal.__doc__ = _pmc.equal.__doc__
fac.__doc__ = _pmc.fac.__doc__
greater.__doc__ = _pmc.greater.__doc__
greater_equal.__doc__ = _pmc.greater_equal.__doc__
ifthen.__doc__ = _pmc.ifthen.__doc__
ifthenelse.__doc__ = _pmc.ifthenelse.__doc__
less.__doc__ = _pmc.less.__doc__
less_equal.__doc__ = _pmc.less_equal.__doc__
ln.__doc__ = _pmc.ln.__doc__
log10.__doc__ = _pmc.log10.__doc__
mapmaximum.__doc__ = _pmc.mapmaximum.__doc__
mapminimum.__doc__ = _pmc.mapminimum.__doc__
max.__doc__ = _pmc.maximum.__doc__
min.__doc__ = _pmc.minimum.__doc__
mul.__doc__ = _pmc.mul.__doc__
nominal.__doc__ = _pmc.nominal.__doc__
nr_worker_threads.__doc__ = _pmc.nr_worker_threads.__doc__
ordinal.__doc__ = _pmc.ordinal.__doc__
power.__doc__ = _pmc.power.__doc__
rounddown.__doc__ = _pmc.rounddown.__doc__
roundoff.__doc__ = _pmc.roundoff.__doc__
roundup.__doc__ = _pmc.roundup.__doc__
scalar.__doc__ = _pmc.scalar.__doc__
set_nr_worker_threads.__doc__ = _pmc.set_nr_worker_threads.__doc__
sin.__doc__ = _pmc.sin.__doc__
slope.__doc__ = _pmc.slope.__doc__
sqr.__doc__ = _pmc.sqr.__doc__
sqrt.__doc__ = _pmc.sqrt.__doc__
sub.__doc__ = _pmc.sub.__doc__
tan.__doc__ = _pmc.tan.__doc__
unequal.__doc__ = _pmc.unequal.__doc__
window4total.__doc__ = _pmc.window4total.__doc__
